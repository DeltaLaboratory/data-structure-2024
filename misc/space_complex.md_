# 공간 복잡도 (Space Complexity)

공간 복잡도는 알고리즘이 실행될 때 사용하는 메모리의 양을 나타내는 척도이다. 이는 입력 크기에 따라 알고리즘이 얼마나 많은 추가 메모리를 필요로 하는지를 측정한다.

## 공간 복잡도의 개념

공간 복잡도는 다음과 같은 요소들을 고려한다:

1. 고정 공간: 입력 크기와 무관하게 항상 필요한 공간
2. 가변 공간: 입력 크기에 따라 변하는 공간
    - 재귀 호출로 인한 스택 공간
    - 동적으로 할당되는 메모리

공간 복잡도는 보통 빅오 표기법(Big O notation)을 사용하여 표현한다.

## 시간 복잡도와의 차이점

1. 측정 대상:
    - 시간 복잡도: 알고리즘 실행에 필요한 시간
    - 공간 복잡도: 알고리즘 실행에 필요한 메모리 공간

2. trade-off 관계:
    - 일반적으로 시간과 공간은 trade-off 관계에 있다. 즉, 더 빠른 알고리즘은 더 많은 메모리를 사용하는 경향이 있다.

3. 최적화 방향:
    - 시간 복잡도: 실행 시간을 줄이는 방향으로 최적화
    - 공간 복잡도: 메모리 사용량을 줄이는 방향으로 최적화

## 코드 예시

다음은 공간 복잡도가 다른 두 가지 피보나치 수열 구현 예시이다:

1. 재귀적 구현 (높은 공간 복잡도):

```c++
int fibonacci(int n) {
    if (n <= 1) return n;
    return fibonacci(n-1) + fibonacci(n-2);
}
```

이 구현은 O(n)의 공간 복잡도를 가진다. 재귀 호출로 인해 콜 스택이 n만큼 쌓이기 때문이다.

2. 반복적 구현 (낮은 공간 복잡도):

```c++
int fibonacci(int n) {
    if (n <= 1) return n;
    int a = 0, b = 1, c;
    for (int i = 2; i <= n; i++) {
        c = a + b;
        a = b;
        b = c;
    }
    return b;
}
```

이 구현은 O(1)의 공간 복잡도를 가진다. 입력 크기와 관계없이 일정한 추가 메모리만을 사용한다.

## 실제 정렬 알고리즘 분석: 병합 정렬 (Merge Sort)

병합 정렬은 분할 정복(divide and conquer) 알고리즘의 대표적인 예시이다.

### 공간 복잡도 분석

병합 정렬의 공간 복잡도는 O(n)이다. 이는 다음과 같은 이유 때문이다:

1. 추가 배열: 병합 과정에서 정렬된 부분 배열을 저장하기 위해 원본 배열과 같은 크기의 추가 배열이 필요하다. 이는 O(n)의 추가 공간을 사용한다.

2. 재귀 호출: 재귀적으로 구현할 경우, 재귀 호출로 인한 스택 공간이 필요하다. 그러나 이는 log n 수준으로 제한되어 전체 공간 복잡도에 큰 영향을 미치지 않는다.

### 구현 예시

```c++
void merge(int arr[], int left, int mid, int right) {
    int i, j, k;
    int n1 = mid - left + 1;
    int n2 = right - mid;
 
    int L[n1], R[n2];
 
    for (i = 0; i < n1; i++)
        L[i] = arr[left + i];
    for (j = 0; j < n2; j++)
        R[j] = arr[mid + 1 + j];
 
    i = 0;
    j = 0;
    k = left;
    while (i < n1 && j < n2) {
        if (L[i] <= R[j]) {
            arr[k] = L[i];
            i++;
        }
        else {
            arr[k] = R[j];
            j++;
        }
        k++;
    }
 
    while (i < n1) {
        arr[k] = L[i];
        i++;
        k++;
    }
 
    while (j < n2) {
        arr[k] = R[j];
        j++;
        k++;
    }
}
 
void mergeSort(int arr[], int left, int right) {
    if (left < right) {
        int mid = left + (right - left) / 2;
 
        mergeSort(arr, left, mid);
        mergeSort(arr, mid + 1, right);
 
        merge(arr, left, mid, right);
    }
}
```

이 구현에서 `merge` 함수 내의 `L[]`와 `R[]` 배열이 추가적인 공간을 사용한다. 이 배열들의 크기는 입력 배열의 부분 크기에 비례하며, 전체적으로 O(n)의 추가 공간을 사용한다.

### 공간 복잡도와 성능

병합 정렬의 O(n) 공간 복잡도는 큰 데이터셋을 다룰 때 제한 요소가 될 수 있다. 메모리가 제한된 환경에서는 퀵 정렬이나 힙 정렬과 같은 O(log n) 또는 O(1) 공간 복잡도를 가진 알고리즘이 선호될 수 있다. 그러나 병합 정렬은 안정적인 정렬이며, 연결 리스트와 같은 순차적 접근 데이터 구조에 효과적으로 적용할 수 있다는 장점이 있다.

결론적으로, 알고리즘 선택 시 시간 복잡도뿐만 아니라 공간 복잡도도 중요한 고려 사항이다. 특히 대규모 데이터나 제한된 메모리 환경에서 작업할 때 공간 복잡도의 중요성이 더욱 부각된다.

# 실제 구현에서 중요한 점
아무리 시간 복잡도가 좋은 알고리즘이라도, 공간 복잡도가 너무 크면 사용할 수 없다.
그리고 보통 공간 복잡도가 높은 알고리즘은, 시작 시간이 느리다.
예를 들어 해시 테이블을 사용하는 알고리즘은, 해시 테이블에 공간을 할당하고, 해시 테이블을 초기화하고, 해시 테이블에 데이터를 넣는 데에 시간이 걸린다.

또한, 현실에서는 메모리 접근이 무조건 상수 시간에 이루어지지 않고, 메모리 공간을 할당하고 해제하는것도 매우 비싼 작업에 속하며, 메모리를 할당하고 해제하는 작업은 메모리를 사용하는 작업보다 더 많은 시간이 걸릴 수 있다.
이러한 이유로 공간 복잡도가 높은 알고리즘을 사용한다면, 메모리 할당 및 초기화 과정을 최적화하고, 레지스터 캐시 레이트를 높이기 위한 방법을 사용하여야 할 것이다.